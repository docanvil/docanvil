use std::path::Path;

use dialoguer::Input;
use owo_colors::OwoColorize;

use super::color::{darken, is_valid_hex, lighten, parse_hex, tint, to_hex, to_rgba};
use crate::config::Config;
use crate::error::Result;

/// Run the theme command: prompt for colors, generate CSS, update config.
pub fn run(project_root: &Path, overwrite: bool) -> Result<()> {
    let config_path = project_root.join("docanvil.toml");
    if !config_path.exists() {
        eprintln!(
            "{} No docanvil.toml found in {}",
            "error:".red().bold(),
            project_root.display()
        );
        eprintln!("  Run `docanvil init` first, or use `--path` to point to your project.");
        std::process::exit(1);
    }

    let config = Config::load(project_root)?;

    // Overwrite guard
    if !overwrite {
        let has_custom_css = config.theme.custom_css.is_some();
        let has_variables = !config.theme.variables.is_empty();
        if has_custom_css || has_variables {
            eprintln!(
                "{} Theme customizations already exist in docanvil.toml",
                "warning:".yellow().bold()
            );
            if has_custom_css {
                eprintln!(
                    "  custom_css = {:?}",
                    config.theme.custom_css.as_deref().unwrap_or("")
                );
            }
            if has_variables {
                eprintln!(
                    "  [theme.variables] has {} entries",
                    config.theme.variables.len()
                );
            }
            eprintln!();
            eprintln!("  Use {} to replace them.", "--overwrite".bold());
            std::process::exit(0);
        }
    }

    // Prompt for colors
    let primary_input: String = Input::new()
        .with_prompt("Primary color (hex)")
        .default("#6366f1".into())
        .validate_with(|input: &String| {
            if is_valid_hex(input) {
                Ok(())
            } else {
                Err("Enter a valid hex color, e.g. #6366f1")
            }
        })
        .interact_text()
        .unwrap_or_else(|_| "#6366f1".into());

    let secondary_input: String = Input::new()
        .with_prompt("Warning/secondary color (hex)")
        .default("#f97316".into())
        .validate_with(|input: &String| {
            if is_valid_hex(input) {
                Ok(())
            } else {
                Err("Enter a valid hex color, e.g. #f97316")
            }
        })
        .interact_text()
        .unwrap_or_else(|_| "#f97316".into());

    let primary = parse_hex(&primary_input).expect("validated above");
    let secondary = parse_hex(&secondary_input).expect("validated above");

    generate_theme(
        project_root,
        &config,
        primary_input,
        secondary_input,
        primary,
        secondary,
        overwrite,
    )
}

/// Core logic extracted for testability.
fn generate_theme(
    project_root: &Path,
    config: &Config,
    primary_hex: String,
    secondary_hex: String,
    primary: super::color::Rgb,
    secondary: super::color::Rgb,
    overwrite: bool,
) -> Result<()> {
    // Derive palette
    let primary_light = lighten(&primary, 0.10);
    let link_hover = darken(&primary, 0.10);
    let sidebar_hover = tint(&primary, 0.95);
    let sidebar_active_bg = tint(&primary, 0.95);
    let sidebar_active_text = darken(&primary, 0.10);
    let note_bg = tint(&primary, 0.95);
    let note_border = lighten(&primary, 0.10);
    let warning_bg = tint(&secondary, 0.95);

    // Build CSS
    let css = format!(
        r#"/* DocAnvil custom theme â€” generated by `docanvil theme`
 *
 * Primary:   {primary_hex}
 * Secondary: {secondary_hex}
 */

:root {{
  /* Primary palette */
  --color-primary: {primary};
  --color-primary-light: {primary_light};
  --color-link: {primary};
  --color-link-hover: {link_hover};

  /* Sidebar */
  --color-sidebar-hover: {sidebar_hover};
  --color-sidebar-active-bg: {sidebar_active_bg};
  --color-sidebar-active-text: {sidebar_active_text};

  /* Admonitions */
  --color-note-bg: {note_bg};
  --color-note-border: {note_border};
  --color-warning-border: {warning_border};
  --color-warning-bg: {warning_bg};

  /* Accents */
  --color-mark-bg: {mark_bg};
  --nav-group-toggle-hover: {nav_toggle_hover};
  --color-focus-ring: {focus_ring};
}}
"#,
        primary_hex = primary_hex,
        secondary_hex = secondary_hex,
        primary = to_hex(&primary),
        primary_light = to_hex(&primary_light),
        link_hover = to_hex(&link_hover),
        sidebar_hover = to_hex(&sidebar_hover),
        sidebar_active_bg = to_hex(&sidebar_active_bg),
        sidebar_active_text = to_hex(&sidebar_active_text),
        note_bg = to_hex(&note_bg),
        note_border = to_hex(&note_border),
        warning_border = to_hex(&secondary),
        warning_bg = to_hex(&warning_bg),
        mark_bg = to_rgba(&primary, 0.12),
        nav_toggle_hover = to_rgba(&primary, 0.06),
        focus_ring = to_rgba(&primary, 0.4),
    );

    // Determine output path
    let css_rel = config
        .theme
        .custom_css
        .as_deref()
        .unwrap_or("theme/custom.css");
    let css_path = project_root.join(css_rel);

    // Ensure parent directory exists
    if let Some(parent) = css_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    std::fs::write(&css_path, css)?;

    // Update docanvil.toml using toml_edit to preserve formatting
    update_config(&project_root.join("docanvil.toml"), css_rel, overwrite)?;

    // Print success
    eprintln!();
    eprintln!("{}", "Theme generated successfully!".green().bold());
    eprintln!();
    eprintln!("  Primary:   {}", primary_hex.bold());
    eprintln!("  Secondary: {}", secondary_hex.bold());
    eprintln!("  CSS:       {}", css_rel.dimmed());
    eprintln!();
    eprintln!("  Run {} to preview your theme.", "docanvil serve".bold());

    Ok(())
}

/// Update docanvil.toml: set custom_css and optionally remove [theme.variables].
fn update_config(config_path: &Path, css_rel: &str, overwrite: bool) -> Result<()> {
    let contents = std::fs::read_to_string(config_path)?;
    let mut doc = contents
        .parse::<toml_edit::DocumentMut>()
        .map_err(|e| crate::error::Error::Render(format!("failed to parse docanvil.toml: {e}")))?;

    // Ensure [theme] table exists
    if doc.get("theme").is_none() {
        doc["theme"] = toml_edit::Item::Table(toml_edit::Table::new());
    }

    let theme = doc["theme"].as_table_mut().unwrap();

    // Set custom_css if not already set (or if overwriting)
    if overwrite || theme.get("custom_css").is_none() {
        theme["custom_css"] = toml_edit::value(css_rel);
    }

    // If overwriting, remove [theme.variables]
    if overwrite {
        theme.remove("variables");
    }

    std::fs::write(config_path, doc.to_string())?;

    Ok(())
}
