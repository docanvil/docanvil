use regex::{Captures, Regex};
use std::collections::HashMap;
use std::sync::LazyLock;

/// Pre-comrak pass: extract custom heading IDs from `### Heading {#custom-id}`
/// syntax and move them to a separate line so the attributes pipeline can
/// process them after comrak renders the heading.
///
/// Converts:
///   `### My Great Heading {#custom-id}`
/// Into:
///   `### My Great Heading\n\n{#custom-id}`
pub fn extract_custom_heading_ids(source: &str) -> String {
    static HEADING_ID_RE: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"(?m)^(#{1,6}\s+.*?)\s+\{#([\w-]+)\}\s*$").unwrap());

    HEADING_ID_RE
        .replace_all(source, "$1\n\n{#$2}")
        .into_owned()
}

/// Post-comrak pass: inject `id` attributes into `<h1>`â€“`<h6>` tags that
/// don't already have one. IDs are generated by slugifying the text content.
/// Duplicate slugs get `-1`, `-2`, etc. appended.
pub fn inject_heading_ids(html: &str) -> String {
    static HEADING_RE: LazyLock<Regex> =
        LazyLock::new(|| Regex::new(r"<(h[1-6])([^>]*)>(.*?)</h[1-6]>").unwrap());
    static TAG_RE: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"<[^>]+>").unwrap());
    static ID_RE: LazyLock<Regex> = LazyLock::new(|| Regex::new(r#"\bid\s*=\s*""#).unwrap());

    let mut seen: HashMap<String, usize> = HashMap::new();

    HEADING_RE
        .replace_all(html, |caps: &Captures| {
            let tag = &caps[1];
            let attrs = &caps[2];
            let inner = &caps[3];

            // Skip if there's already an id attribute
            if ID_RE.is_match(attrs) {
                return caps[0].to_string();
            }

            // Strip HTML tags from inner content to get plain text
            let text = TAG_RE.replace_all(inner, "");
            let base_slug = slug::slugify(text.trim());

            let id = if base_slug.is_empty() {
                "heading".to_string()
            } else {
                base_slug
            };

            // Handle duplicates
            let count = seen.entry(id.clone()).or_insert(0);
            let final_id = if *count == 0 {
                *count += 1;
                id
            } else {
                let suffixed = format!("{}-{}", id, count);
                *count += 1;
                suffixed
            };

            format!("<{} id=\"{}\"{}>{}</{}>", tag, final_id, attrs, inner, tag)
        })
        .into_owned()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic_heading_gets_id() {
        let html = "<h2>Installation Guide</h2>";
        let result = inject_heading_ids(html);
        assert_eq!(
            result,
            r#"<h2 id="installation-guide">Installation Guide</h2>"#
        );
    }

    #[test]
    fn heading_with_existing_id_not_modified() {
        let html = r#"<h2 id="custom-id">Title</h2>"#;
        let result = inject_heading_ids(html);
        assert_eq!(result, html);
    }

    #[test]
    fn duplicate_headings_get_suffixed_ids() {
        let html = "<h2>Foo</h2>\n<h2>Foo</h2>\n<h2>Foo</h2>";
        let result = inject_heading_ids(html);
        assert!(result.contains(r#"id="foo""#));
        assert!(result.contains(r#"id="foo-1""#));
        assert!(result.contains(r#"id="foo-2""#));
    }

    #[test]
    fn tags_inside_headings_stripped_for_slug() {
        let html = "<h2>Hello <code>world</code></h2>";
        let result = inject_heading_ids(html);
        assert!(result.contains(r#"id="hello-world""#));
        // Inner HTML preserved
        assert!(result.contains("<code>world</code>"));
    }

    #[test]
    fn h1_through_h6_all_handled() {
        let html = "<h1>A</h1><h3>B</h3><h6>C</h6>";
        let result = inject_heading_ids(html);
        assert!(result.contains(r#"<h1 id="a">"#));
        assert!(result.contains(r#"<h3 id="b">"#));
        assert!(result.contains(r#"<h6 id="c">"#));
    }

    #[test]
    fn heading_with_em_tag() {
        let html = "<h2>Getting <em>Started</em></h2>";
        let result = inject_heading_ids(html);
        assert!(result.contains(r#"id="getting-started""#));
    }

    #[test]
    fn preserves_existing_classes() {
        let html = r#"<h2 class="special">Title</h2>"#;
        let result = inject_heading_ids(html);
        assert!(result.contains(r#"id="title""#));
        assert!(result.contains(r#"class="special""#));
    }

    // --- extract_custom_heading_ids tests ---

    #[test]
    fn custom_heading_id_extracted() {
        let source = "### My Great Heading {#custom-id}";
        let result = extract_custom_heading_ids(source);
        assert_eq!(result, "### My Great Heading\n\n{#custom-id}");
    }

    #[test]
    fn custom_heading_id_h1() {
        let source = "# Top Level {#top}";
        let result = extract_custom_heading_ids(source);
        assert_eq!(result, "# Top Level\n\n{#top}");
    }

    #[test]
    fn custom_heading_id_h6() {
        let source = "###### Deep Heading {#deep}";
        let result = extract_custom_heading_ids(source);
        assert_eq!(result, "###### Deep Heading\n\n{#deep}");
    }

    #[test]
    fn heading_without_custom_id_unchanged() {
        let source = "## Normal Heading";
        let result = extract_custom_heading_ids(source);
        assert_eq!(result, "## Normal Heading");
    }

    #[test]
    fn multiple_headings_with_custom_ids() {
        let source = "## First {#one}\n\nSome text\n\n### Second {#two}";
        let result = extract_custom_heading_ids(source);
        assert!(result.contains("## First\n\n{#one}"));
        assert!(result.contains("### Second\n\n{#two}"));
    }

    #[test]
    fn custom_id_with_hyphens() {
        let source = "## API Reference {#api-v2-reference}";
        let result = extract_custom_heading_ids(source);
        assert_eq!(result, "## API Reference\n\n{#api-v2-reference}");
    }
}
